{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#alternative-queries","title":"Alternative Queries","text":"<p>Alternative queries is a library created to help with handcrafted SQL queries. It works by providing a class that represent the queries where its parameter types are checked by <code>Pydantic</code>.</p> <p>If you want to write reusable and nested handcrafted SQL queries, you can check more information on the Alternative Queries Documentation. If you want to know how Alternative Queries can help you, check the Why use Alternative Queries? section of the documentation.</p>"},{"location":"#installation","title":"Installation","text":"<p>The library is available in the Python Package Index.</p> Bash<pre><code>pip install altqq\n</code></pre>"},{"location":"#quick-start","title":"Quick Start","text":"<p>To start, define a class by inheriting the <code>altqq.Query</code> class. The class should have a query following the python formatting standards. The variable names inside the <code>__query__</code> must match the other attributes defined on the class.</p> Python<pre><code>import altqq\n\nclass SelectUserByFirstName(altqq.Query):\n    __query__ = \"\"\"\n        SELECT * FROM \"Users\"\n        WHERE first_name = {first_name}\n    \"\"\"\n    first_name: str\n</code></pre> <p>The class can be used like a <code>dataclass</code>. In fact, classes inheriting the <code>altqq.Query</code> class are turned into a <code>Pydantic</code> <code>dataclass</code>.</p> Python<pre><code>query = SelectUserByFirstName(first_name=\"arietta\")\n</code></pre> <p>The object can be converted into a query suitable for a DBMS library of your choice. For example, calling the <code>altqq.to_pyodbc</code> function will convert the object to <code>PyODBCQuery</code> which provides the query string and the parameters.</p> Python<pre><code>pyodbc_query = altqq.to_pyodbc(query)\nprint(pyodbc_query.query)\n#\n#        SELECT * FROM \"Users\"\n#        WHERE first_name = ?\n#\nprint(pyodbc_query.parameters)\n# ['arietta']\n</code></pre>"},{"location":"api/","title":"API Reference","text":""},{"location":"api/#modeling","title":"Modeling","text":"<p>These are used for defining queries.</p>"},{"location":"api/#altqq.Query","title":"<code>altqq.Query</code>","text":"<p>Base class for query definitions.</p> <p>This class can be inherited instead of providing the <code>QueryMeta</code> as the class metaclass.</p> Source code in <code>src/altqq/structs.py</code> Python<pre><code>class Query(metaclass=QueryMeta):\n    \"\"\"Base class for query definitions.\n\n    This class can be inherited instead of providing the `QueryMeta` as the\n    class metaclass.\n    \"\"\"\n\n    __query__: ClassVar[str]\n</code></pre>"},{"location":"api/#altqqnonparameter","title":"<code>altqq.NonParameter</code>","text":"<p>Non-parameter type hint.</p>"},{"location":"api/#altqqlistparameter","title":"<code>altqq.ListParameter</code>","text":"<p>List parameter type hint.</p>"},{"location":"api/#altqqcalculated","title":"<code>altqq.Calculated</code>","text":"<p>Calculated value assignment.</p>"},{"location":"api/#pyodbc","title":"PyODBC","text":"<p>These are used for working with PyODBC.</p>"},{"location":"api/#altqq.to_pyodbc","title":"<code>altqq.to_pyodbc(query)</code>","text":"<p>Converts a <code>Query</code> to its corresponding <code>PyODBCQuery</code> object.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>Query</code> <p>Query to translate to PyODBC</p> required <p>Returns:</p> Name Type Description <code>PyODBCQuery</code> <code>PyODBCQuery</code> <p>Equivalent query for PyODBC usage.</p> Source code in <code>src/altqq/__init__.py</code> Python<pre><code>def to_pyodbc(query: Query) -&gt; PyODBCQuery:\n    \"\"\"Converts a `Query` to its corresponding `PyODBCQuery` object.\n\n    Args:\n        query (Query): Query to translate to PyODBC\n\n    Returns:\n        PyODBCQuery: Equivalent query for PyODBC usage.\n    \"\"\"\n    return Translators.PYODBC(query)\n</code></pre>"},{"location":"api/#altqq.PyODBCQuery","title":"<code>altqq.PyODBCQuery</code>  <code>dataclass</code>","text":"<p>Converted <code>Query</code> object for PyODBC usage.</p> Source code in <code>src/altqq/translators/pyodbc.py</code> Python<pre><code>@dc.dataclass\nclass PyODBCQuery:\n    \"\"\"Converted `Query` object for PyODBC usage.\"\"\"\n\n    query: str\n    parameters: Iterable[Any]\n</code></pre>"},{"location":"api/#psycopg","title":"Psycopg","text":"<p>These are used for working with Psycopg.</p>"},{"location":"api/#altqq.to_psycopg","title":"<code>altqq.to_psycopg(query)</code>","text":"<p>Converts a <code>Query</code> to its corresponding <code>PsycopgQuery</code> object.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>Query</code> <p>Query to translate to Psycopg</p> required <p>Returns:</p> Name Type Description <code>PsycopgQuery</code> <code>PsycopgQuery</code> <p>Equivalent query for Psycopg usage.</p> Source code in <code>src/altqq/__init__.py</code> Python<pre><code>def to_psycopg(query: Query) -&gt; PsycopgQuery:\n    \"\"\"Converts a `Query` to its corresponding `PsycopgQuery` object.\n\n    Args:\n        query (Query): Query to translate to Psycopg\n\n    Returns:\n        PsycopgQuery: Equivalent query for Psycopg usage.\n    \"\"\"\n    return Translators.PSYCOPG(query)\n</code></pre>"},{"location":"api/#altqq.PsycopgQuery","title":"<code>altqq.PsycopgQuery</code>  <code>dataclass</code>","text":"<p>Converted <code>Query</code> object for Psycopg usage.</p> Source code in <code>src/altqq/translators/psycopg.py</code> Python<pre><code>@dc.dataclass\nclass PsycopgQuery:\n    \"\"\"Converted `Query` object for Psycopg usage.\"\"\"\n\n    query: str\n    parameters: Tuple[Any, ...]\n</code></pre>"},{"location":"api/#plain-text","title":"Plain Text","text":"<p>These are used for working with plain text SQL.</p>"},{"location":"api/#altqq.to_plain_text","title":"<code>altqq.to_plain_text(query)</code>","text":"<p>Converts a <code>Query</code> to a plain text SQL.</p> <p>The conversion to plain text also handles some of the data types. None is converted to <code>NULL</code>, numeric values are written as they are and string values and other object types are escaped using <code>'</code>.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>Query</code> <p>Query to convert.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Query as plain text.</p> Source code in <code>src/altqq/__init__.py</code> Python<pre><code>def to_plain_text(query: Query) -&gt; str:\n    \"\"\"Converts a `Query` to a plain text SQL.\n\n    The conversion to plain text also handles some of the data types. None\n    is converted to `NULL`, numeric values are written as they are and\n    string values and other object types are escaped using `'`.\n\n    Args:\n        query (Query): Query to convert.\n\n    Returns:\n        str: Query as plain text.\n    \"\"\"\n    return Translators.PLAIN_TEXT(query)\n</code></pre>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#changelog","title":"Changelog","text":""},{"location":"changelog/#007","title":"0.0.7","text":"<ul> <li>Fix PostgreSQL issue with non-string non-parameter values ([#17]).</li> </ul>"},{"location":"changelog/#006","title":"0.0.6","text":"<ul> <li>Fix <code>altqq.Calculated</code> not being providing new a descriptor for each attribute   (#14)</li> <li>Add <code>altqq.ListParameter</code> for providing list of values as parameters (#15)</li> </ul>"},{"location":"changelog/#005","title":"0.0.5","text":"<ul> <li>Nested <code>altqq.Query</code> are now checked by instance (#13)</li> </ul>"},{"location":"changelog/#004","title":"0.0.4","text":"<ul> <li>Subclass check improvements on <code>altqq.Query</code> (#12)</li> </ul>"},{"location":"changelog/#003","title":"0.0.3","text":"<ul> <li>Add <code>psycopg</code> support (#9)</li> <li>Add <code>mysql</code> support (#10)</li> <li>Documentation Improvements (#11)</li> </ul>"},{"location":"changelog/#002","title":"0.0.2","text":"<ul> <li>Initial Release</li> </ul>"},{"location":"rationale/","title":"Why use Alternative Queries?","text":"<p>Arguments for ORM, Stored Procedures, handcrafted queries, and other methods of managing your database interactions will <code>NOT</code> be the content of this section. The assumption is you decided to work on writing handcrafted queries.</p> <p>The content of this section is to present several ways in which Alternative Queries can help you in your journey to writing nicer handcrafted queries.</p>"},{"location":"rationale/#typed-parameters","title":"Typed Parameters","text":"<p>Typing has been added to python since version <code>3.5</code> and for good reason. Typing reduces the space for errors when working with code. In the example below, there are no clues as to what the <code>id</code> should be. Even the query context can not help in this situation since database IDs can be <code>UUID</code>, <code>int</code>, or <code>str</code> type.</p> Python<pre><code>my_query = \"\"\"\n    SELECT * FROM \"Users\" where id = {id}\n\"\"\"\n</code></pre> <p>Using Alternative Queries allows definition of types with the query. It also checks that all the parameters required by the query are provided. This means that unlike a string query, one does not need to remember to call <code>format</code> every time.</p> Python<pre><code>import uuid\nimport altqq\n\nclass MyQuery(altqq.Query):\n    __query__ = \"\"\"\n        SELECT * FROM \"Users\" where id = {id}\n    \"\"\"\n    id: uuid.UUID\n\nMyQuery(id=10) # Throws ValidationError\nMyQuery() # Throws ValidationError\nMyQuery(id=uuid.uuid4()) # Works perfectly\n</code></pre>"},{"location":"rationale/#managing-ordered-parameters","title":"Managing Ordered Parameters","text":"<p>Alternative Queries helps you in managing your query parameters. For example, for ODBC databases, <code>pyodbc</code> does not allow named parameters. It means that to reuse queries, one needs to make note of the parameters, as they must be in order. For example:</p> Python<pre><code>import uuid\n\nmy_query = \"\"\"\n    SELECT * from \"Users\" where \"id\" = ? and \"name\" = ?\n\"\"\"\nparameters = [uuid.uuid4(), \"Arie\"]\n</code></pre> <p>The Alternative Queries equivalent provides a named option to help manage the parameters. These names are also suggested if one is using a Python IDE. This also reduces redundancy if a query uses a parameter multiple times.</p> Python<pre><code>import uuid\nimport altqq\n\nclass MyQuery(altqq.Query):\n    __query__ = \"\"\"\n        SELECT * from \"Users\" where \"id\" = {id} and \"name\" = {name}\n    \"\"\"\n    id: uuid.UUID\n    name: str\n\n# The order and parameter names are provided as suggestion by the IDE\nMyQuery(id=uuid.uuid4(), name=\"Arie\")\n</code></pre>"},{"location":"rationale/#managing-named-parameters","title":"Managing Named Parameters","text":"<p><code>psycopg</code> and <code>mysql</code> supports named parameters. For these libraries, Alternative Queries help in nested queries. Manually merging the query strings can introduce name conflicts. On the other hand, Alternative Queries perform substitution on a query basis, allowing name reuse. For example:</p> Python<pre><code>query1 = \"\"\"\n    SELECT * from \"Teachers\" where \"id\" = %(id)s and \"name\" = %(name)s\n\"\"\"\nparameters1 = {\"id\": uuid.uuid4(), \"name\": \"Arie\"}\n\nquery2 = \"\"\"\n    SELECT * from \"Students\" where \"id\" = %(id)s and \"name\" = %(name)s\n\"\"\"\nparameters2 = {\"id\": uuid.uuid4(), \"name\": \"Falsita\"}\n\n# query1 and query2 use the same parameter names\nquery3 = f\"{query1} UNION ALL {query2}\"\n# this actually does not work since the same keys will overwrite values\nparameters3 = {**parameters1, **parameters2}\n</code></pre> <p>Alternative Queries take the parameters together with their respective class. This allows Alternative Queries to scope the names of the parameters being provided. When working with <code>psycopg</code> and <code>mysql</code>, Alternative Queries will still provide the parameters as a <code>tuple</code>, which means the names do not matter to the final result.</p> Python<pre><code>import uuid\nimport altqq\n\nclass Query1(altqq.Query):\n    __query__ = \"\"\"\n        SELECT * from \"Teachers\" where \"id\" = {id} and \"name\" = {name}\n    \"\"\"\n    id: uuid.UUID\n    name: str\n\nquery1 = Query1(id=uuid.uuid4(), name=\"Arie\")\n\nclass Query2(altqq.Query):\n    __query__ = \"\"\"\n        SELECT * from \"Students\" where \"id\" = {id} and \"name\" = {name}\n    \"\"\"\n    id: uuid.UUID\n    name: str\n\nquery2 = Query2(id=uuid.uuid4(), name=\"Falsita\")\n\nclass Query3(altqq.Query):\n    __query__ = \"\"\"\n        {query1} UNION ALL {query2}\n    \"\"\"\n    query1: altqq.Query\n    query2: altqq.Query\n\nquery3 = Query3(query1=query1, query2=query2)\n\nres = altqq.to_psycopg(query3)\nprint(res.parameters) # (UUID('...'), 'Arie', UUID('...'), 'Falsita')\n</code></pre>"},{"location":"rationale/#nesting-queries","title":"Nesting Queries","text":"<p>Alternative Queries help in reusing and nesting queries. One common example of a reusable template is paging.</p> Python<pre><code>def page_query(query, parameters, page, items_per_page):\n    page = \"\"\"\n        SELECT * FROM ( {query} ) as base\n        ...\n    \"\"\"\n    return page_query, (*parameters, page, items_per_page)\n\npage_query(my_query, my_parameters, page, items_per_page)\n</code></pre> <p>The Alternative Queries equivalent provides type checking during run-time, as well as removing the logic for handling the parameter merging. Having ordered parameters makes parameter merging easier. However, the lack of named parameters can make defining parameters error-prone. Alternative Queries provide a named option, while doing the parameter merging under the hood.</p> Python<pre><code>import altqq\n\nclass Paging(altqq.Query):\n    __query__ = \"\"\"\n        SELECT * FROM ( {query} ) as base\n        ...\n    \"\"\"\n    query: altqq.Query\n\n    page: int\n    items_per_page: int\n\nquery = Paging(MyQuery(...), page, items_per_page)\n</code></pre>"},{"location":"user-guide/","title":"User Guide","text":"<p>This is a more thorough guide on the functionalities of Alternative Queries.</p> <p>As a general usage rule, rely on the objects provided by the <code>altqq</code> module. Consider the internal modules in the <code>altqq.*</code> as highly unstable.</p>"},{"location":"user-guide/#typed-queries","title":"Typed Queries","text":"<p>The most basic functionality of Alternative Queries is to provide types to the query parameters.</p> Python<pre><code>import altqq\n\nclass MyQuery(altqq.Query):\n    __query__ = \"...\"\n\n    parameter1: str\n    parameter2: int\n</code></pre> <p>The types are checked using <code>Pydantic</code>, so the type casting rules that <code>Pydantic</code> follow also applies. For more details, read the Pydantic Types documentation.</p>"},{"location":"user-guide/#non-parameter-substitution","title":"Non-Parameter Substitution","text":"<p>Sometimes, there is a need to provide a value not as a parameter, but as an actual value. A simple example of this is wanting a query to work on different tables.</p> Python<pre><code>import altqq\n\nclass MyQuery(altqq.Query):\n    __query__ = \"\"\" SELECT * FROM \"{table}\" \"\"\"\n    table: altqq.NonParameter[str]\n\nres = altqq.to_pyodbc(MyQuery(\"Users\"))\n\nprint(res.query) #  SELECT * FROM \"Users\"\nprint(res.parameters) # []\n</code></pre> <p>These values must be defined using the <code>altqq.NonParameter</code> types. These types of values must be defined explicitly, as they can introduce SQL injections if used incorrectly.</p>"},{"location":"user-guide/#nested-queries","title":"Nested Queries","text":"<p>To use a query inside a query, simply define the type of class attribute as <code>altqq.Query</code>. This will merge all the parameters of the child queries to the parent query.</p> Python<pre><code>import altqq\n\nclass Paging(altqq.Query):\n    __query__ = \"\"\"\n        SELECT * FROM ( {query} ) as base\n        ...\n    \"\"\"\n    query: altqq.Query\n\n    page: int\n    items_per_page: int\n\nquery = Paging(MyQuery(...), page, items_per_page)\n</code></pre>"},{"location":"user-guide/#calculated-values","title":"Calculated Values","text":"<p>There are cases in which one would prefer to compute the value of a parameter. For example, defining the columns to fetch inside a <code>SELECT</code> query.</p> Python<pre><code>import altqq\n\nclass Select(altqq.Query):\n    __query__ = \"\"\"\n        SELECT {_columns} FROM \"{table}\"\n    \"\"\"\n    table: altqq.NonParameter[str]\n    columns: altqq.NonParameter[typing.Iterable[str]]\n\n    _columns: altqq.NonParameter[str] = altqq.Calculated\n\n    def __post_init__(self):\n        # Convert [\"a\", \"b\", \"c\"] to \"a\",\"b\",\"c\"\n        self._columns = \",\".join(f'\"{c}\"'for c in self.columns)\n\nquery = Select(table=\"Users\", columns=[\"id\", \"first_name\", \"last_name\"])\nres = altqq.to_pyodbc(query)\nprint(res.query) # SELECT \"id\",\"first_name\",\"last_name\" FROM \"Users\"\n</code></pre> <p>Assigning a value as <code>altqq.Calculated</code> means that the value will not be provided by the user. Internally, <code>altqq.Calculated</code> is just replaced with <code>dataclasses.field(init=False)</code>. Given that all <code>altqq.Query</code> objects are <code>Pydantic</code> <code>dataclass</code>, the calculated values can be assigned inside the <code>__post_init__</code> method.</p> <p>As defined by the <code>Pydantic</code> <code>dataclass</code> behavior, the types for the assignment inside the <code>__post_init__</code> method are not checked.</p>"},{"location":"user-guide/#list-parameters","title":"List Parameters","text":"<p>For list that are used as parameters, a special <code>altqq.ListParameter</code> typing can be used to denote that <code>altqq</code> should expand the list as a parameter.</p> Python<pre><code>import altqq\n\nclass SelectUser(altqq.Query):\n    __query__ = \"\"\"\n        SELECT * FROM Users WHERE user_id in {user_id}\n    \"\"\"\n\n    user_id: altqq.ListParameter[int]\n\n\nquery = SelectUser(user_id=[1,2,3])\nres = altqq.to_pyodbc(query)\nprint(res.query) # SELECT * FROM Users WHERE user_id in (?,?,?)\n</code></pre>"},{"location":"user-guide/#additional-validation","title":"Additional Validation","text":"<p>As <code>altqq.Query</code> objects are <code>Pydantic</code> <code>dataclass</code> internally, one can also perform more rigid validation to the parameter values. For more details, read the documentation on Pydantic Dataclasses.</p>"}]}